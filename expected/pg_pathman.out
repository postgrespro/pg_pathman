\set VERBOSITY terse
CREATE SCHEMA pathman;
CREATE EXTENSION pg_pathman SCHEMA pathman;
CREATE SCHEMA test;
CREATE TABLE test.hash_rel (
    id      SERIAL PRIMARY KEY,
    value   INTEGER);
SELECT pathman.create_hash_partitions('test.hash_rel', 'value', 3);
NOTICE:  function test.hash_rel_hash_insert_trigger_func() does not exist, skipping
NOTICE:  function test.hash_rel_hash_update_trigger_func() does not exist, skipping
 create_hash_partitions 
------------------------
                      3
(1 row)

CREATE TABLE test.range_rel (
    id SERIAL PRIMARY KEY,
    dt TIMESTAMP,
    txt TEXT);
CREATE INDEX ON test.range_rel (dt);
SELECT pathman.create_range_partitions('test.range_rel', 'dt', '2015-01-01'::DATE, '1 month'::INTERVAL, 3);
NOTICE:  sequence "range_rel_seq" does not exist, skipping
 create_range_partitions 
-------------------------
                       4
(1 row)

CREATE TABLE test.num_range_rel (
    id SERIAL PRIMARY KEY,
    txt TEXT);
SELECT pathman.create_range_partitions('test.num_range_rel', 'id', 0, 1000, 3);
NOTICE:  sequence "num_range_rel_seq" does not exist, skipping
 create_range_partitions 
-------------------------
                       4
(1 row)

INSERT INTO test.num_range_rel
SELECT g, md5(g::TEXT) FROM generate_series(1, 3000) as g;
INSERT INTO test.range_rel (dt, txt)
SELECT g, md5(g::TEXT) FROM generate_series('2015-01-01', '2015-04-30', '1 day'::interval) as g;
INSERT INTO test.hash_rel VALUES (1, 1);
INSERT INTO test.hash_rel VALUES (2, 2);
INSERT INTO test.hash_rel VALUES (3, 3);
INSERT INTO test.hash_rel VALUES (4, 4);
INSERT INTO test.hash_rel VALUES (5, 5);
INSERT INTO test.hash_rel VALUES (6, 6);
VACUUM;
/* update triggers test */
SELECT pathman.create_hash_update_trigger('test.hash_rel');
 create_hash_update_trigger 
----------------------------
 
(1 row)

UPDATE test.hash_rel SET value = 7 WHERE value = 6;
EXPLAIN (COSTS OFF) SELECT * FROM test.hash_rel WHERE value = 7;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on hash_rel_1
         Filter: (value = 7)
(3 rows)

SELECT * FROM test.hash_rel WHERE value = 7;
 id | value 
----+-------
  6 |     7
(1 row)

SELECT pathman.create_range_update_trigger('test.num_range_rel');
 create_range_update_trigger 
-----------------------------
 
(1 row)

UPDATE test.num_range_rel SET id = 3001 WHERE id = 1;
EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE id = 3001;
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on num_range_rel_4
         Filter: (id = 3001)
(3 rows)

SELECT * FROM test.num_range_rel WHERE id = 3001;
  id  |               txt                
------+----------------------------------
 3001 | c4ca4238a0b923820dcc509a6f75849b
(1 row)

SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
SET enable_seqscan = ON;
EXPLAIN (COSTS OFF) SELECT * FROM test.hash_rel;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on hash_rel_0
   ->  Seq Scan on hash_rel_1
   ->  Seq Scan on hash_rel_2
(4 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.hash_rel WHERE value = 2;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on hash_rel_2
         Filter: (value = 2)
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.hash_rel WHERE value = 2 OR value = 1;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on hash_rel_1
         Filter: (value = 1)
   ->  Seq Scan on hash_rel_2
         Filter: (value = 2)
(5 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE id > 2500;
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on num_range_rel_3
         Filter: (id > 2500)
   ->  Seq Scan on num_range_rel_4
(4 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE id >= 1000 AND id < 3000;
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on num_range_rel_2
   ->  Seq Scan on num_range_rel_3
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE id >= 1500 AND id < 2500;
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on num_range_rel_2
         Filter: (id >= 1500)
   ->  Seq Scan on num_range_rel_3
         Filter: (id < 2500)
(5 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE (id >= 500 AND id < 1500) OR (id > 2500);
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on num_range_rel_1
         Filter: (id >= 500)
   ->  Seq Scan on num_range_rel_2
         Filter: (id < 1500)
   ->  Seq Scan on num_range_rel_3
         Filter: (id > 2500)
   ->  Seq Scan on num_range_rel_4
(8 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.range_rel WHERE dt > '2015-02-15';
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Append
   ->  Seq Scan on range_rel_2
         Filter: (dt > 'Sun Feb 15 00:00:00 2015'::timestamp without time zone)
   ->  Seq Scan on range_rel_3
   ->  Seq Scan on range_rel_4
(5 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.range_rel WHERE dt >= '2015-02-01' AND dt < '2015-03-01';
          QUERY PLAN           
-------------------------------
 Append
   ->  Seq Scan on range_rel_2
(2 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.range_rel WHERE dt >= '2015-02-15' AND dt < '2015-03-15';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Append
   ->  Seq Scan on range_rel_2
         Filter: (dt >= 'Sun Feb 15 00:00:00 2015'::timestamp without time zone)
   ->  Seq Scan on range_rel_3
         Filter: (dt < 'Sun Mar 15 00:00:00 2015'::timestamp without time zone)
(5 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.range_rel WHERE (dt >= '2015-01-15' AND dt < '2015-02-15') OR (dt > '2015-03-15');
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Append
   ->  Seq Scan on range_rel_1
         Filter: (dt >= 'Thu Jan 15 00:00:00 2015'::timestamp without time zone)
   ->  Seq Scan on range_rel_2
         Filter: (dt < 'Sun Feb 15 00:00:00 2015'::timestamp without time zone)
   ->  Seq Scan on range_rel_3
         Filter: (dt > 'Sun Mar 15 00:00:00 2015'::timestamp without time zone)
   ->  Seq Scan on range_rel_4
(8 rows)

SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
SET enable_seqscan = OFF;
EXPLAIN (COSTS OFF) SELECT * FROM test.hash_rel;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on hash_rel_0
   ->  Seq Scan on hash_rel_1
   ->  Seq Scan on hash_rel_2
(4 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.hash_rel WHERE value = 2;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on hash_rel_2
         Filter: (value = 2)
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.hash_rel WHERE value = 2 OR value = 1;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on hash_rel_1
         Filter: (value = 1)
   ->  Seq Scan on hash_rel_2
         Filter: (value = 2)
(5 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE id > 2500;
                           QUERY PLAN                           
----------------------------------------------------------------
 Append
   ->  Index Scan using num_range_rel_3_pkey on num_range_rel_3
         Index Cond: (id > 2500)
   ->  Seq Scan on num_range_rel_4
(4 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE id >= 1000 AND id < 3000;
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on num_range_rel_2
   ->  Seq Scan on num_range_rel_3
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE id >= 1500 AND id < 2500;
                           QUERY PLAN                           
----------------------------------------------------------------
 Append
   ->  Index Scan using num_range_rel_2_pkey on num_range_rel_2
         Index Cond: (id >= 1500)
   ->  Index Scan using num_range_rel_3_pkey on num_range_rel_3
         Index Cond: (id < 2500)
(5 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE (id >= 500 AND id < 1500) OR (id > 2500);
                           QUERY PLAN                           
----------------------------------------------------------------
 Append
   ->  Index Scan using num_range_rel_1_pkey on num_range_rel_1
         Index Cond: (id >= 500)
   ->  Index Scan using num_range_rel_2_pkey on num_range_rel_2
         Index Cond: (id < 1500)
   ->  Index Scan using num_range_rel_3_pkey on num_range_rel_3
         Index Cond: (id > 2500)
   ->  Seq Scan on num_range_rel_4
(8 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.range_rel WHERE dt > '2015-02-15';
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Append
   ->  Index Scan using range_rel_2_dt_idx on range_rel_2
         Index Cond: (dt > 'Sun Feb 15 00:00:00 2015'::timestamp without time zone)
   ->  Seq Scan on range_rel_3
   ->  Seq Scan on range_rel_4
(5 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.range_rel WHERE dt >= '2015-02-01' AND dt < '2015-03-01';
          QUERY PLAN           
-------------------------------
 Append
   ->  Seq Scan on range_rel_2
(2 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.range_rel WHERE dt >= '2015-02-15' AND dt < '2015-03-15';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Index Scan using range_rel_2_dt_idx on range_rel_2
         Index Cond: (dt >= 'Sun Feb 15 00:00:00 2015'::timestamp without time zone)
   ->  Index Scan using range_rel_3_dt_idx on range_rel_3
         Index Cond: (dt < 'Sun Mar 15 00:00:00 2015'::timestamp without time zone)
(5 rows)

EXPLAIN (COSTS OFF) SELECT * FROM test.range_rel WHERE (dt >= '2015-01-15' AND dt < '2015-02-15') OR (dt > '2015-03-15');
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Append
   ->  Index Scan using range_rel_1_dt_idx on range_rel_1
         Index Cond: (dt >= 'Thu Jan 15 00:00:00 2015'::timestamp without time zone)
   ->  Index Scan using range_rel_2_dt_idx on range_rel_2
         Index Cond: (dt < 'Sun Feb 15 00:00:00 2015'::timestamp without time zone)
   ->  Index Scan using range_rel_3_dt_idx on range_rel_3
         Index Cond: (dt > 'Sun Mar 15 00:00:00 2015'::timestamp without time zone)
   ->  Seq Scan on range_rel_4
(8 rows)

/*
 * Test split and merge
 */
/* Split first partition in half */
SELECT pathman.split_range_partition('test.num_range_rel_1', 500);
NOTICE:  Creating new partition...
NOTICE:  Copying data to new partition...
NOTICE:  Altering original partition...
NOTICE:  Done!
 split_range_partition 
-----------------------
 {0,1000}
(1 row)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE id BETWEEN 100 AND 700;
                           QUERY PLAN                           
----------------------------------------------------------------
 Append
   ->  Index Scan using num_range_rel_1_pkey on num_range_rel_1
         Index Cond: (id >= 100)
   ->  Index Scan using num_range_rel_5_pkey on num_range_rel_5
         Index Cond: (id <= 700)
(5 rows)

SELECT pathman.split_range_partition('test.range_rel_1', '2015-01-15'::DATE);
NOTICE:  Creating new partition...
NOTICE:  Copying data to new partition...
NOTICE:  Altering original partition...
NOTICE:  Done!
  split_range_partition  
-------------------------
 {01-01-2015,02-01-2015}
(1 row)

/* Merge two partitions into one */
SELECT pathman.merge_range_partitions('test.num_range_rel_1', 'test.num_range_rel_' || currval('test.num_range_rel_seq'));
NOTICE:  Altering first partition...
NOTICE:  Copying data...
NOTICE:  Dropping second partition...
NOTICE:  Done!
 merge_range_partitions 
------------------------
 
(1 row)

EXPLAIN (COSTS OFF) SELECT * FROM test.num_range_rel WHERE id BETWEEN 100 AND 700;
                           QUERY PLAN                           
----------------------------------------------------------------
 Append
   ->  Index Scan using num_range_rel_1_pkey on num_range_rel_1
         Index Cond: ((id >= 100) AND (id <= 700))
(3 rows)

SELECT pathman.merge_range_partitions('test.range_rel_1', 'test.range_rel_' || currval('test.range_rel_seq'));
NOTICE:  Altering first partition...
NOTICE:  Copying data...
NOTICE:  Dropping second partition...
NOTICE:  Done!
 merge_range_partitions 
------------------------
 
(1 row)

/* Append and prepend partitions */
SELECT pathman.append_partition('test.num_range_rel');
NOTICE:  Appending new partition...
NOTICE:  Done!
 append_partition 
------------------
 
(1 row)

SELECT pathman.prepend_partition('test.num_range_rel');
NOTICE:  Prepending new partition...
NOTICE:  Done!
 prepend_partition 
-------------------
 
(1 row)

SELECT pathman.append_partition('test.range_rel');
NOTICE:  Appending new partition...
NOTICE:  Done!
 append_partition 
------------------
 
(1 row)

SELECT pathman.prepend_partition('test.range_rel');
NOTICE:  Prepending new partition...
NOTICE:  Done!
 prepend_partition 
-------------------
 
(1 row)

/*
 * Clean up
 */
SELECT pathman.drop_hash_partitions('test.hash_rel');
NOTICE:  drop cascades to trigger test_hash_rel_insert_trigger on table test.hash_rel
NOTICE:  function test.hash_rel_hash_update_trigger_func() does not exist, skipping
 drop_hash_partitions 
----------------------
 
(1 row)

DROP TABLE test.hash_rel CASCADE;
SELECT pathman.drop_range_partitions('test.num_range_rel');
 drop_range_partitions 
-----------------------
 
(1 row)

DROP TABLE test.num_range_rel CASCADE;
SELECT pathman.drop_range_partitions('test.range_rel');
 drop_range_partitions 
-----------------------
 
(1 row)

DROP TABLE test.range_rel CASCADE;
SELECT * FROM pathman.pathman_config;
 id | relname | attname | parttype 
----+---------+---------+----------
(0 rows)

DROP EXTENSION pg_pathman;
/* Test that everithing works fine without schemas */
CREATE EXTENSION pg_pathman;
/* Hash */
CREATE TABLE hash_rel (
    id      SERIAL PRIMARY KEY,
    value   INTEGER);
INSERT INTO hash_rel (value) SELECT g FROM generate_series(1, 10000) as g;
SELECT create_hash_partitions('hash_rel', 'value', 3);
NOTICE:  function hash_rel_hash_insert_trigger_func() does not exist, skipping
NOTICE:  function hash_rel_hash_update_trigger_func() does not exist, skipping
 create_hash_partitions 
------------------------
                      3
(1 row)

SELECT partition_data('hash_rel');
NOTICE:  Copying data to hash_rel_0 (condition: ((value % 3) = 0))
NOTICE:  Copying data to hash_rel_1 (condition: ((value % 3) = 1))
NOTICE:  Copying data to hash_rel_2 (condition: ((value % 3) = 2))
 partition_data 
----------------
              0
(1 row)

EXPLAIN (COSTS OFF) SELECT * FROM hash_rel WHERE id = 1234;
                      QUERY PLAN                      
------------------------------------------------------
 Append
   ->  Index Scan using hash_rel_0_pkey on hash_rel_0
         Index Cond: (id = 1234)
   ->  Index Scan using hash_rel_1_pkey on hash_rel_1
         Index Cond: (id = 1234)
   ->  Index Scan using hash_rel_2_pkey on hash_rel_2
         Index Cond: (id = 1234)
(7 rows)

/* Range */
CREATE TABLE range_rel (
    id SERIAL PRIMARY KEY,
    dt TIMESTAMP);
INSERT INTO range_rel (dt) SELECT g FROM generate_series('2010-01-01'::date, '2010-12-31'::date, '1 day') as g;
SELECT create_range_partitions('range_rel', 'dt', '2010-01-01'::date, '1 month'::interval, 12);
NOTICE:  sequence "range_rel_seq" does not exist, skipping
 create_range_partitions 
-------------------------
                      13
(1 row)

SELECT partition_data('range_rel');
NOTICE:  Copying data to range_rel_1 (condition: ((dt >= 'Fri Jan 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Mon Feb 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_2 (condition: ((dt >= 'Mon Feb 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Mon Mar 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_3 (condition: ((dt >= 'Mon Mar 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Thu Apr 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_4 (condition: ((dt >= 'Thu Apr 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Sat May 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_5 (condition: ((dt >= 'Sat May 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Tue Jun 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_6 (condition: ((dt >= 'Tue Jun 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Thu Jul 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_7 (condition: ((dt >= 'Thu Jul 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Sun Aug 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_8 (condition: ((dt >= 'Sun Aug 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Wed Sep 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_9 (condition: ((dt >= 'Wed Sep 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Fri Oct 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_10 (condition: ((dt >= 'Fri Oct 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Mon Nov 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_11 (condition: ((dt >= 'Mon Nov 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Wed Dec 01 00:00:00 2010'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_12 (condition: ((dt >= 'Wed Dec 01 00:00:00 2010'::timestamp without time zone) AND (dt < 'Sat Jan 01 00:00:00 2011'::timestamp without time zone)))
NOTICE:  Copying data to range_rel_13 (condition: ((dt >= 'Sat Jan 01 00:00:00 2011'::timestamp without time zone) AND (dt < 'Tue Feb 01 00:00:00 2011'::timestamp without time zone)))
 partition_data 
----------------
              0
(1 row)

SELECT merge_range_partitions('range_rel_1', 'range_rel_2');
NOTICE:  Altering first partition...
NOTICE:  Copying data...
NOTICE:  Dropping second partition...
NOTICE:  Done!
 merge_range_partitions 
------------------------
 
(1 row)

SELECT split_range_partition('range_rel_1', '2010-02-15'::date);
NOTICE:  Creating new partition...
NOTICE:  Copying data to new partition...
NOTICE:  Altering original partition...
NOTICE:  Done!
  split_range_partition  
-------------------------
 {01-01-2010,03-01-2010}
(1 row)

SELECT append_partition('range_rel');
NOTICE:  Appending new partition...
NOTICE:  Done!
 append_partition 
------------------
 
(1 row)

SELECT prepend_partition('range_rel');
NOTICE:  Prepending new partition...
NOTICE:  Done!
 prepend_partition 
-------------------
 
(1 row)

EXPLAIN (COSTS OFF) SELECT * FROM range_rel WHERE dt < '2010-03-01';
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on range_rel_1
   ->  Seq Scan on range_rel_14
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM range_rel WHERE dt > '2010-12-15';
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Append
   ->  Seq Scan on range_rel_12
         Filter: (dt > 'Wed Dec 15 00:00:00 2010'::timestamp without time zone)
   ->  Seq Scan on range_rel_13
(4 rows)

/* Manual partitions creation */
CREATE TABLE range_rel_archive (CHECK (dt >= '2000-01-01' AND dt < '2005-01-01')) INHERITS (range_rel);
SELECT on_update_partitions('range_rel'::regclass::oid);
 on_update_partitions 
----------------------
 
(1 row)

EXPLAIN (COSTS OFF) SELECT * FROM range_rel WHERE dt < '2010-03-01';
             QUERY PLAN              
-------------------------------------
 Append
   ->  Seq Scan on range_rel_archive
   ->  Seq Scan on range_rel_16
   ->  Seq Scan on range_rel_1
   ->  Seq Scan on range_rel_14
(5 rows)

DROP EXTENSION pg_pathman;
